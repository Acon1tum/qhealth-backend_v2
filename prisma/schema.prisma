// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // Change to your DB provider (e.g., mysql)
  url      = env("DATABASE_URL")
}

// Organization model for healthcare organizations
model Organization {
  id          String   @id @default(uuid()) // Primary key, UUID
  name        String   @unique // Organization name
  description String?  // Organization description
  address     String?  // Organization address
  phone       String?  // Organization phone number
  email       String?  // Organization email
  website     String?  // Organization website
  isActive    Boolean  @default(true) // Whether the organization is active
  createdAt   DateTime @default(now()) // Timestamp when organization is created
  updatedAt   DateTime @updatedAt // Timestamp when organization data is updated

  // Relationships
  users       User[]   // Users belonging to this organization
}

// User model for login (Doctors, Patients, Admins, Super Admins)
model User {
  id             String   @id @default(uuid()) // Primary key, UUID
  email          String   @unique // Unique email for login authentication
  password       String // Hashed password for secure login
  role           Role // Role to distinguish between doctor, patient, admin, and super admin
  organizationId String?  // Foreign key to Organization (nullable for super admins and patients)
  createdAt      DateTime @default(now()) // Timestamp when user is created
  updatedAt      DateTime @updatedAt // Timestamp when user data is updated
  
  // Profile Picture
  profilePicture String? // Base64 encoded profile picture
  profilePictureVerified Boolean @default(false) // Whether profile picture has been verified
  profilePictureVerifiedBy String? // User ID who verified the profile picture
  profilePictureVerifiedAt DateTime? // When the profile picture was verified

  // Relationships
  organization           Organization? @relation(fields: [organizationId], references: [id]) // Organization the user belongs to
  consultationsAsDoctor  Consultation[]   @relation("DoctorConsultations") // Consultations where the user is the doctor
  consultationsAsPatient Consultation[]   @relation("PatientConsultations") // Consultations where the user is the patient
  doctorInfo             DoctorInfo? // Additional information for doctors (only exists if the user is a doctor)
  patientInfo            PatientInfo? // Additional information for patients (only exists if the user is a patient)
  doctorCategories       DoctorCategory[] @relation("DoctorCategories") // Doctors' categories

  // Additional relations for DoctorSchedule, EmergencyContact, and InsuranceInfo
  doctorSchedules   DoctorSchedule[]
  emergencyContacts EmergencyContact[]
  insuranceInfos    InsuranceInfo[]
  refreshTokens     RefreshToken[] // Refresh tokens for JWT authentication
  
  // Security and audit relations
  auditLogs              AuditLog[] // Audit logs for this user
  securityEvents         SecurityEvent[] // Security events for this user
  resolvedSecurityEvents SecurityEvent[] @relation("ResolvedSecurityEvents") // Security events resolved by this user
  
  // New appointment and reschedule relations
  patientAppointments    AppointmentRequest[] @relation("PatientAppointments") // Appointments where user is patient
  doctorAppointments     AppointmentRequest[] @relation("DoctorAppointments") // Appointments where user is doctor
  rescheduleRequests     RescheduleRequest[] @relation("UserRescheduleRequests") // Reschedule requests initiated by user
  
  // New privacy and sharing relations
  sharedConsultations    ConsultationSharing[] @relation("SharedConsultations") // Consultations shared with this doctor
  consultationSharing    ConsultationSharing[] @relation("ConsultationSharing") // Consultations shared by this user
  patientMedicalHistory  PatientMedicalHistory[] @relation("PatientMedicalHistory") // Medical history records for this patient
  createdMedicalRecords  PatientMedicalHistory[] @relation("CreatedMedicalRecords") // Medical records created by this user
  
  // HealthScan privacy and sharing relations
  sharedHealthScans      HealthScanSharing[] @relation("SharedHealthScans") // Health scans shared with this doctor
  healthScanSharing      HealthScanSharing[] @relation("HealthScanSharing") // Health scans shared by this user
  
  // Prescription and diagnosis relations
  prescriptionsAsDoctor  Prescription[] @relation("DoctorPrescriptions") // Prescriptions written by this doctor
  prescriptionsAsPatient Prescription[] @relation("PatientPrescriptions") // Prescriptions for this patient
  diagnosesAsDoctor      Diagnosis[] @relation("DoctorDiagnoses") // Diagnoses made by this doctor
  diagnosesAsPatient      Diagnosis[] @relation("PatientDiagnoses") // Diagnoses for this patient
  
  @@index([profilePictureVerified])
  @@index([profilePictureVerifiedBy])
}

// Enum for different user roles
enum Role {
  DOCTOR
  PATIENT
  ADMIN
  SUPER_ADMIN
}

// Doctor Category model to categorize doctors by specialization (e.g., Cardiologist, Dermatologist)
model DoctorCategory {
  id          String  @id @default(uuid()) // Primary key, UUID
  name        String  @unique // Category name (e.g., Cardiologist, Dermatologist)
  description String? // A short description of the category (optional)
  doctors     User[]  @relation("DoctorCategories") // List of doctors that belong to this category
}

// Doctor Information model for additional details about the doctor
model DoctorInfo {
  id             String   @id @default(uuid()) // Primary key, UUID
  userId         String   @unique // Make userId unique for one-to-one relationship
  firstName      String // Doctor's first name
  middleName     String? // Doctor's middle name (optional)
  lastName       String // Doctor's last name
  gender         Sex // Doctor's gender (Male/Female/Other)
  dateOfBirth    DateTime // Doctor's date of birth
  contactNumber  String // Doctor's contact number
  address        String // Doctor's address
  bio            String // Brief biography of the doctor
  specialization String // Specialization or field of medicine the doctor practices
  qualifications String // Doctor's qualifications (e.g., MBBS, MD)
  experience     Int // Number of years of experience in the medical field
  
  // Medical License Information
  prcId          String? // PRC (Professional Regulation Commission) ID number
  ptrId          String? // PTR (Professional Tax Receipt) ID number
  medicalLicenseLevel MedicalLicenseLevel? // Medical license level (S1, S2, S3)
  philHealthAccreditation PhilHealthAccreditation? // PhilHealth accreditation status
  licenseNumber  String? // Medical license number
  licenseExpiry  DateTime? // Medical license expiry date
  isLicenseActive Boolean @default(true) // Whether the medical license is currently active
  
  // Additional License Information
  additionalCertifications String? // Additional medical certifications (JSON string for flexibility)
  licenseIssuedBy String? // Authority that issued the license (e.g., "PRC", "Medical Board")
  licenseIssuedDate DateTime? // When the license was issued
  renewalRequired Boolean @default(true) // Whether the license requires periodic renewal
  
  // ID Document Uploads (Base64 encoded)
  prcIdImage     String? // Base64 encoded PRC ID image
  ptrIdImage     String? // Base64 encoded PTR ID image
  medicalLicenseImage String? // Base64 encoded medical license image
  additionalIdImages String? // JSON string containing additional ID images (base64 encoded)
  idDocumentsVerified Boolean @default(false) // Whether ID documents have been verified
  idDocumentsVerifiedBy String? // User ID who verified the documents
  idDocumentsVerifiedAt DateTime? // When the documents were verified

  user User @relation(fields: [userId], references: [id]) // Relationship to User (Doctor)
  
  @@index([prcId])
  @@index([ptrId])
  @@index([medicalLicenseLevel])
  @@index([philHealthAccreditation])
  @@index([isLicenseActive])
  @@index([licenseExpiry])
  @@index([idDocumentsVerified])
  @@index([idDocumentsVerifiedBy])
}

// Enum for sex
enum Sex {
  MALE
  FEMALE
  OTHER
}

// Medical License Level enum for Philippine medical practice levels
enum MedicalLicenseLevel {
  S1 // General Practitioner Accreditation - for general practitioners and primary care doctors
  S2 // Specialist Accreditation - for doctors with specialized training in specific medical fields
  S3 // Subspecialist Accreditation - for subspecialists with advanced training in specific areas
}

// PhilHealth Accreditation Status enum
enum PhilHealthAccreditation {
  ACCREDITED     // Fully accredited with PhilHealth
  PENDING        // Accreditation application pending
  SUSPENDED      // Accreditation temporarily suspended
  EXPIRED        // Accreditation has expired
  NOT_ACCREDITED // Not accredited with PhilHealth
  UNDER_REVIEW   // Accreditation under review
}

// Doctor Schedule model to manage doctor availability (e.g., availability on specific days and times)
model DoctorSchedule {
  id        String   @id @default(uuid()) // Primary key, UUID
  doctorId  String // Reference to Doctor (User)
  dayOfWeek String // Day of the week the doctor is available (e.g., Monday, Tuesday)
  startTime DateTime // Start time of doctor's availability on this day
  endTime   DateTime // End time of doctor's availability on this day
  isAvailable Boolean @default(false) // Whether the doctor is available on this day

  doctor User @relation(fields: [doctorId], references: [id]) // Relationship to Doctor (User)

  @@unique([doctorId, dayOfWeek])
}

// Consultation model that stores consultation details between a doctor and a patient
model Consultation {
  id               String    @id @default(uuid()) // Primary key, UUID
  doctorId         String // Foreign key to User (Doctor)
  patientId        String // Foreign key to User (Patient)
  startTime        DateTime // The start time of the consultation
  endTime          DateTime? // The end time of the consultation (optional)
  consultationCode String   @unique // Unique consultation code for tracking and identification (9 characters)
  isPublic        Boolean  @default(false) // Whether consultation is public for other doctors
  notes           String?  // Doctor's private notes about the consultation
  diagnosis       String?  // Doctor's diagnosis
  treatment       String?  // Treatment plan
  followUpDate    DateTime? // Follow-up appointment date
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  doctor     User        @relation("DoctorConsultations", fields: [doctorId], references: [id]) // Doctor who conducted the consultation
  patient    User        @relation("PatientConsultations", fields: [patientId], references: [id]) // Patient being consulted
  healthScan HealthScan? // Health scan results related to the consultation (optional)
  appointmentRequest AppointmentRequest? // Links back to the original appointment request
  privacySettings ConsultationPrivacy[] // Privacy settings for this consultation
  sharedWith     ConsultationSharing[] // Which doctors can access this consultation
  medicalHistory PatientMedicalHistory[] // Medical history records related to this consultation
  prescriptions  Prescription[] // Prescriptions issued during this consultation
  diagnoses      Diagnosis[] // Diagnoses made during this consultation
}

// HealthScan model that stores health scan data (e.g., heart rate, stress level, etc.)
model HealthScan {
  id              String  @id @default(uuid()) // Primary key, UUID
  consultationId  String  @unique // Foreign key to Consultation - make unique for one-to-one relation
  bloodPressure   String? // Blood pressure (e.g., 130/80)
  heartRate       Float? // Heart rate in bpm (e.g., 84 bpm)
  spO2            Float? // Oxygen saturation level (e.g., 98%)
  respiratoryRate Float? // Respiratory rate in breaths/min (e.g., 11.7)
  stressLevel     Float? // Stress level score (e.g., 1.9)
  stressScore     Float? // Stress score (e.g., 284.8)
  hrvSdnn         Float? // HRV SDNN (e.g., 43.25 ms)
  hrvRmsdd        Float? // HRV RMSSD (e.g., 42.28 ms)
  generalWellness Float? // General wellness score (e.g., 71.71)

  // Health Risk Assessment
  generalRisk              Float? // General health risk (e.g., 4.8%)
  coronaryHeartDisease     Float? // Coronary heart disease risk (e.g., 2.6%)
  congestiveHeartFailure   Float? // Congestive heart failure risk (e.g., 0.3%)
  intermittentClaudication Float? // Intermittent claudication risk (e.g., 0.75%)
  strokeRisk               Float? // Stroke risk (e.g., 1.5%)

  // COVID-19 Risk
  covidRisk Float? // COVID-19 risk (e.g., 2.8%)

  // Health Parameters (used to calculate diabetes and hypertension risk)
  height                Float? // Height in cm (e.g., 170)
  weight                Float? // Weight in kg (e.g., 65)
  smoker                Boolean? // Whether the person is a smoker (true/false)
  hypertension          Boolean? // Whether the person has hypertension (true/false)
  bpMedication          Boolean? // Whether the person is on blood pressure medication
  diabetic              Int? // Diabetes status: 0 = no diabetes, 1 = prediabetes, 2 = diabetic
  waistCircumference    Float? // Waist circumference in cm (e.g., 80)
  heartDisease          Boolean? // Whether the person has heart disease (true/false)
  depression            Boolean? // Whether the person has depression (true/false)
  totalCholesterol      Float? // Total cholesterol in mg/dL (e.g., 200)
  hdl                   Float? // HDL cholesterol in mg/dL (e.g., 50)
  parentalHypertension  Int? // Parental history of hypertension: 0 = none, 1 = one parent, 2 = both parents
  physicalActivity      Boolean? // Whether the person engages in regular physical activity
  healthyDiet           Boolean? // Whether the person follows a healthy diet
  antiHypertensive      Boolean? // Whether the person uses anti-hypertensive medication
  historyBloodGlucose   Boolean? // Whether the person has a history of high blood glucose
  historyFamilyDiabetes Int? // Family history of diabetes: 0 = none, 1 = one parent/sibling, 2 = both parents/siblings

  consultation Consultation @relation(fields: [consultationId], references: [id]) // Relation to Consultation
  privacySettings HealthScanPrivacy[] // Privacy settings for this health scan
  sharedWith HealthScanSharing[] // Which doctors can access this health scan
}

// Patient Information model to store additional details about the patient
model PatientInfo {
  id               String            @id @default(uuid()) // Primary key, UUID
  userId           String            @unique // Make userId unique for one-to-one relationship
  fullName         String // Full name of the patient
  gender           Sex // Patient's gender (Male/Female/Other)
  dateOfBirth      DateTime // Patient's date of birth
  contactNumber    String // Patient's contact number
  address          String // Patient's address
  weight           Float // Patient's weight (in kg)
  height           Float // Patient's height (in cm)
  bloodType        String // Patient's blood type (e.g., A+, B-)
  emergencyContact EmergencyContact? // Emergency contact info (optional)
  medicalHistory   String? // Patient's medical history (optional)
  allergies        String? // Patient's allergies (optional)
  medications      String? // Current medications (optional)
  insuranceInfo    InsuranceInfo? // Patient's insurance information
  
  // PhilHealth Information
  philHealthId     String? // PhilHealth ID number (e.g., 12-345678901-2)
  philHealthStatus String? // PhilHealth membership status (e.g., ACTIVE, INACTIVE, PENDING)
  philHealthCategory String? // PhilHealth category (e.g., INDIVIDUAL, FAMILY, SPONSORED)
  philHealthExpiry DateTime? // PhilHealth membership expiry date
  philHealthMemberSince DateTime? // When the patient became a PhilHealth member
  
  // PhilHealth ID Document Upload (Base64 encoded)
  philHealthIdImage String? // Base64 encoded PhilHealth ID image
  philHealthIdVerified Boolean @default(false) // Whether PhilHealth ID has been verified
  philHealthIdVerifiedBy String? // User ID who verified the PhilHealth ID
  philHealthIdVerifiedAt DateTime? // When the PhilHealth ID was verified

  user User @relation(fields: [userId], references: [id]) // Relation to Patient User
  
  @@index([philHealthId])
  @@index([philHealthStatus])
  @@index([philHealthIdVerified])
  @@index([philHealthIdVerifiedBy])
}

// Emergency Contact model
model EmergencyContact {
  id             String  @id @default(uuid()) // Primary key, UUID
  patientId      String  @unique // Foreign key to Patient (User) - unique for one-to-one relation
  contactName    String // Emergency contact name
  relationship   String // Relationship to patient (e.g., Mother, Father, Spouse)
  contactNumber  String // Emergency contact number
  contactAddress String? // Emergency contact address (optional)

  patient     User        @relation(fields: [patientId], references: [id], map: "EmergencyContact_patient_fkey") // Relation to Patient
  patientInfo PatientInfo @relation(fields: [patientId], references: [userId]) // Relation to PatientInfo
}

// Insurance Info model
model InsuranceInfo {
  id               String @id @default(uuid()) // Primary key, UUID
  patientId        String @unique // Foreign key to Patient (User) - unique for one-to-one relation
  providerName     String // Insurance provider name
  policyNumber     String // Insurance policy number
  insuranceContact String // Insurance contact information (e.g., phone number or email)

  patient     User        @relation(fields: [patientId], references: [id], map: "InsuranceInfo_patient_fkey") // Relation to Patient
  patientInfo PatientInfo @relation(fields: [patientId], references: [userId]) // Relation to PatientInfo
}

// Refresh Token model for JWT refresh tokens
model RefreshToken {
  id        String   @id @default(uuid())
  userId    String   // Foreign key to User
  token     String   @unique // The actual refresh token string
  expiresAt DateTime // When the token expires
  createdAt DateTime @default(now()) // When the token was created
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("refresh_tokens")
}

// Audit Log model for comprehensive activity tracking
model AuditLog {
  id           String         @id @default(uuid())
  userId       String? // Foreign key to User (nullable for system events)
  action       String // Action performed (e.g., LOGIN, CREATE, UPDATE, DELETE)
  category     AuditCategory // Category of the audit log
  level        AuditLevel // Severity level of the audit log
  description  String // Human-readable description of the action
  ipAddress    String // IP address of the user
  userAgent    String // User agent string
  resourceType String? // Type of resource affected (e.g., USER, CONSULTATION)
  resourceId   String? // ID of the resource affected
  details      Json? // Additional details in JSON format
  timestamp    DateTime @default(now()) // When the action occurred
  severity     String // Severity level as string (low, medium, high, critical)
  
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@index([userId])
  @@index([timestamp])
  @@index([category])
  @@index([level])
  @@map("audit_logs")
}

// Security Event model for tracking security-related incidents
model SecurityEvent {
  id          String     @id @default(uuid())
  eventType   String // Type of security event (e.g., AUTH_FAILURE, RATE_LIMIT_VIOLATION)
  severity    AuditLevel // Severity level of the security event
  description String // Description of the security event
  ipAddress   String // IP address associated with the event
  userAgent   String // User agent string
  userId      String? // Foreign key to User (nullable for anonymous events)
  details     Json? // Additional details in JSON format
  timestamp   DateTime @default(now()) // When the event occurred
  resolved    Boolean @default(false) // Whether the security event has been resolved
  resolvedAt  DateTime? // When the event was resolved
  resolvedBy  String? // User who resolved the event
  
  user       User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  resolvedByUser User? @relation("ResolvedSecurityEvents", fields: [resolvedBy], references: [id], onDelete: SetNull)
  
  @@index([userId])
  @@index([timestamp])
  @@index([eventType])
  @@index([severity])
  @@index([resolved])
  @@map("security_events")
}

// Enums for audit logging
enum AuditCategory {
  AUTHENTICATION
  AUTHORIZATION
  DATA_ACCESS
  DATA_MODIFICATION
  SECURITY
  SYSTEM
  USER_ACTIVITY
}

enum AuditLevel {
  INFO
  WARNING
  ERROR
  CRITICAL
}

// Appointment Request model for patient-initiated consultation requests
model AppointmentRequest {
  id          String             @id @default(uuid())
  patientId   String             // Patient requesting the appointment
  doctorId    String             // Doctor being requested
  requestedDate DateTime         // Preferred date for consultation
  requestedTime String           // Preferred time slot
  reason      String             // Reason for consultation
  status      AppointmentStatus  @default(PENDING)
  priority    Priority           @default(NORMAL)
  notes       String?            // Additional notes from patient
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  
  patient    User                @relation("PatientAppointments", fields: [patientId], references: [id])
  doctor     User                @relation("DoctorAppointments", fields: [doctorId], references: [id])
  consultation Consultation?      @relation(fields: [consultationId], references: [id]) // Links to actual consultation when confirmed
  consultationId String?          @unique // Foreign key to Consultation (unique for one-to-one relation)
  rescheduleRequests RescheduleRequest[] // Track reschedule requests
  
  @@index([patientId])
  @@index([doctorId])
  @@index([status])
  @@index([requestedDate])
}

// Reschedule Request model for handling appointment rescheduling
model RescheduleRequest {
  id                String                 @id @default(uuid())
  appointmentId     String                 // Reference to the appointment being rescheduled
  requestedBy       String                 // User ID who requested the reschedule (patient or doctor)
  requestedByRole   Role                   // Role of the person requesting reschedule
  currentDate       DateTime               // Current scheduled date
  currentTime       String                 // Current scheduled time
  newDate           DateTime               // Proposed new date
  newTime           String                 // Proposed new time
  reason            String                 // Reason for rescheduling
  status            RescheduleStatus       @default(PENDING)
  proposedBy        RescheduleProposedBy   // Who proposed the new time
  notes             String?                // Additional notes
  createdAt         DateTime               @default(now())
  updatedAt         DateTime               @updatedAt
  resolvedAt        DateTime?              // When the reschedule was resolved
  
  appointment       AppointmentRequest      @relation(fields: [appointmentId], references: [id])
  requestedByUser   User                   @relation("UserRescheduleRequests", fields: [requestedBy], references: [id])
  
  @@index([appointmentId])
  @@index([requestedBy])
  @@index([status])
  @@index([newDate])
}

// Appointment Status enum
enum AppointmentStatus {
  PENDING     // Waiting for doctor approval
  CONFIRMED   // Doctor approved and scheduled
  CANCELLED   // Cancelled by patient or doctor
  COMPLETED   // Consultation completed
  REJECTED    // Doctor rejected the request
  RESCHEDULED // Appointment was rescheduled
}

// Reschedule Status enum
enum RescheduleStatus {
  PENDING     // Waiting for approval from the other party
  APPROVED    // Reschedule request approved
  REJECTED    // Reschedule request rejected
  CANCELLED   // Reschedule request cancelled
}

// Reschedule Proposed By enum
enum RescheduleProposedBy {
  PATIENT     // Patient proposed the new time
  DOCTOR      // Doctor proposed the new time
  SYSTEM      // System suggested the new time (e.g., due to conflict)
}

// Priority enum
enum Priority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// Consultation Privacy model to manage privacy settings
model ConsultationPrivacy {
  id             String   @id @default(uuid())
  consultationId String   // Reference to the consultation
  settingType    PrivacySettingType // Type of privacy setting
  isEnabled      Boolean  @default(true) // Whether this privacy setting is enabled
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  consultation   Consultation @relation(fields: [consultationId], references: [id])
  
  @@unique([consultationId, settingType])
  @@index([consultationId])
}

// Consultation Sharing model to control which doctors can access consultations
model ConsultationSharing {
  id             String   @id @default(uuid())
  consultationId String   // Reference to the consultation being shared
  sharedWithDoctorId String // Doctor who can access this consultation
  accessLevel    AccessLevel @default(READ_ONLY) // Level of access granted
  sharedBy       String   // User who shared the consultation (patient or original doctor)
  sharedAt       DateTime @default(now())
  expiresAt      DateTime? // When access expires (optional)
  isActive       Boolean  @default(true) // Whether the sharing is still active
  
  consultation   Consultation @relation(fields: [consultationId], references: [id])
  sharedWithDoctor User     @relation("SharedConsultations", fields: [sharedWithDoctorId], references: [id])
  sharedByUser     User     @relation("ConsultationSharing", fields: [sharedBy], references: [id])
  
  @@unique([consultationId, sharedWithDoctorId])
  @@index([consultationId])
  @@index([sharedWithDoctorId])
  @@index([sharedBy])
}

// Patient Medical History model for comprehensive health records
model PatientMedicalHistory {
  id              String   @id @default(uuid())
  patientId       String   // Reference to the patient
  consultationId  String?  // Optional reference to specific consultation
  recordType      MedicalRecordType // Type of medical record
  title           String   // Title/description of the record
  content         String   // Content of the medical record
  isPublic        Boolean  @default(false) // Whether this record is public
  isSensitive     Boolean  @default(false) // Whether this is sensitive information
  createdBy       String   // User who created this record
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  patient         User     @relation("PatientMedicalHistory", fields: [patientId], references: [id])
  consultation    Consultation? @relation(fields: [consultationId], references: [id])
  creator         User     @relation("CreatedMedicalRecords", fields: [createdBy], references: [id])
  privacySettings MedicalRecordPrivacy[] // Privacy settings for this record
  
  @@index([patientId])
  @@index([consultationId])
  @@index([isPublic])
  @@index([recordType])
}

// Medical Record Privacy model
model MedicalRecordPrivacy {
  id                   String   @id @default(uuid())
  medicalRecordId      String   // Reference to the medical record
  settingType          PrivacySettingType // Type of privacy setting
  isEnabled            Boolean  @default(true) // Whether this privacy setting is enabled
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  
  medicalRecord        PatientMedicalHistory @relation(fields: [medicalRecordId], references: [id])
  
  @@unique([medicalRecordId, settingType])
  @@index([medicalRecordId])
}

// HealthScan Privacy model to manage privacy settings for health scan data
model HealthScanPrivacy {
  id             String   @id @default(uuid())
  healthScanId   String   // Reference to the health scan
  settingType    PrivacySettingType // Type of privacy setting
  isEnabled      Boolean  @default(true) // Whether this privacy setting is enabled
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  healthScan     HealthScan @relation(fields: [healthScanId], references: [id])
  
  @@unique([healthScanId, settingType])
  @@index([healthScanId])
}

// HealthScan Sharing model to control which doctors can access health scan data
model HealthScanSharing {
  id                   String   @id @default(uuid())
  healthScanId         String   // Reference to the health scan being shared
  sharedWithDoctorId   String   // Doctor who can access this health scan
  accessLevel          AccessLevel @default(READ_ONLY) // Level of access granted
  sharedBy             String   // User who shared the health scan (patient or original doctor)
  sharedAt             DateTime @default(now())
  expiresAt            DateTime? // When access expires (optional)
  isActive             Boolean  @default(true) // Whether the sharing is still active
  
  healthScan           HealthScan @relation(fields: [healthScanId], references: [id])
  sharedWithDoctor     User       @relation("SharedHealthScans", fields: [sharedWithDoctorId], references: [id])
  sharedByUser         User       @relation("HealthScanSharing", fields: [sharedBy], references: [id])
  
  @@unique([healthScanId, sharedWithDoctorId])
  @@index([healthScanId])
  @@index([sharedWithDoctorId])
  @@index([sharedBy])
}

// Privacy Setting Type enum
enum PrivacySettingType {
  PUBLIC_READ        // Can be read by other doctors
  PUBLIC_WRITE       // Can be modified by other doctors (rarely used)
  SHARED_SPECIFIC    // Shared with specific doctors only
  PATIENT_APPROVED   // Requires patient approval for sharing
  TIME_LIMITED       // Access expires after certain time
  ROLE_BASED         // Access based on doctor role/specialization
}

// Access Level enum
enum AccessLevel {
  READ_ONLY          // Can only read/view the consultation
  READ_WITH_NOTES    // Can read and see doctor's notes
  READ_WITH_HISTORY  // Can read and see related medical history
  FULL_ACCESS        // Full access (rare, usually for specialists)
}

// Medical Record Type enum
enum MedicalRecordType {
  CONSULTATION_NOTES // Notes from a consultation
  DIAGNOSIS          // Medical diagnosis
  TREATMENT_PLAN     // Treatment plan
  MEDICATION         // Medication prescribed
  LAB_RESULTS        // Laboratory test results
  IMAGING_RESULTS    // X-ray, MRI, etc. results
  ALLERGIES          // Patient allergies
  CHRONIC_CONDITIONS // Chronic medical conditions
  SURGICAL_HISTORY   // Previous surgeries
  FAMILY_HISTORY     // Family medical history
  LIFESTYLE          // Lifestyle factors
  VACCINATIONS       // Vaccination history
}

// Prescription model for managing medication prescriptions
model Prescription {
  id              String   @id @default(uuid()) // Primary key, UUID
  patientId       String   // Reference to the patient
  doctorId        String   // Reference to the doctor who prescribed
  consultationId  String?  // Optional reference to the consultation
  medicationName  String   // Name of the medication
  dosage          String   // Dosage instructions (e.g., "500mg twice daily")
  frequency       String   // How often to take (e.g., "twice daily", "as needed")
  duration        String   // Duration of treatment (e.g., "7 days", "until finished")
  instructions    String?  // Additional instructions for the patient
  quantity        Int?     // Quantity prescribed
  refills         Int      @default(0) // Number of refills allowed
  isActive        Boolean  @default(true) // Whether the prescription is still active
  prescribedAt    DateTime @default(now()) // When the prescription was written
  expiresAt       DateTime? // When the prescription expires
  notes           String?  // Doctor's notes about the prescription
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  patient      User         @relation("PatientPrescriptions", fields: [patientId], references: [id])
  doctor       User         @relation("DoctorPrescriptions", fields: [doctorId], references: [id])
  consultation Consultation? @relation(fields: [consultationId], references: [id])
  
  @@index([patientId])
  @@index([doctorId])
  @@index([consultationId])
  @@index([isActive])
  @@index([prescribedAt])
}

// Diagnosis model for managing medical diagnoses
model Diagnosis {
  id              String   @id @default(uuid()) // Primary key, UUID
  patientId       String   // Reference to the patient
  doctorId        String   // Reference to the doctor who made the diagnosis
  consultationId  String?  // Optional reference to the consultation
  diagnosisCode   String?  // ICD-10 or other medical coding system code
  diagnosisName   String   // Name of the diagnosis/condition
  description     String?  // Detailed description of the diagnosis
  severity        DiagnosisSeverity @default(MILD) // Severity of the condition
  status          DiagnosisStatus @default(ACTIVE) // Current status of the diagnosis
  onsetDate       DateTime? // When the condition started
  diagnosedAt     DateTime @default(now()) // When the diagnosis was made
  resolvedAt      DateTime? // When the diagnosis was resolved (if applicable)
  notes           String?  // Additional notes about the diagnosis
  isPrimary       Boolean  @default(false) // Whether this is the primary diagnosis
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  patient      User         @relation("PatientDiagnoses", fields: [patientId], references: [id])
  doctor       User         @relation("DoctorDiagnoses", fields: [doctorId], references: [id])
  consultation Consultation? @relation(fields: [consultationId], references: [id])
  
  @@index([patientId])
  @@index([doctorId])
  @@index([consultationId])
  @@index([diagnosisCode])
  @@index([status])
  @@index([diagnosedAt])
}

// Diagnosis Severity enum
enum DiagnosisSeverity {
  MILD       // Mild condition
  MODERATE   // Moderate condition
  SEVERE     // Severe condition
  CRITICAL   // Critical/life-threatening condition
}

// Diagnosis Status enum
enum DiagnosisStatus {
  ACTIVE     // Currently active diagnosis
  RESOLVED   // Diagnosis has been resolved
  CHRONIC    // Chronic condition (ongoing)
  SUSPECTED  // Suspected but not confirmed
  RULED_OUT  // Condition was suspected but ruled out
}
